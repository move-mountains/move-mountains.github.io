<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://move-mountains.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://move-mountains.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Docker/Docker的常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/29/Docker/Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2022-05-29T15:20:50.000Z" itemprop="datePublished">2022-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/29/Docker/Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 的常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Docker-的常用命令"><a href="#Docker-的常用命令" class="headerlink" title="Docker 的常用命令"></a>Docker 的常用命令</h1><h2 id="列出本机上的所有镜像"><a href="#列出本机上的所有镜像" class="headerlink" title="列出本机上的所有镜像"></a>列出本机上的所有镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [-f] &lt;镜像ID&gt;</span><br></pre></td></tr></table></figure>

<p>注意：当使用了本地镜像创建了 container,对应的镜像就不能删除（无论对应的 container 是否正在运行），必须先删除 container，或者加上<code>-f</code>参数。</p>
<h2 id="创建新容器并运行"><a href="#创建新容器并运行" class="headerlink" title="创建新容器并运行"></a>创建新容器并运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run [可选参数] &lt;镜像名称&gt; [启动后需执行的命令] [ARG参数]</span><br></pre></td></tr></table></figure>

<p><code>[启动后需执行的命令]</code>会覆盖掉 Dockerfile 中定义的执行命令，也可指定可执行文件<br><code>[ARG参数]</code>同理，也是覆盖 Dockerfile 中定义的 ARG 参数的值，但只能覆盖，不能新定义（理论上新定义的 ARG 参数即使生效也不会在 Dockerfile 中起作用）</p>
<p>常用可选参数列表如下。</p>
<ul>
<li>-d: 后台运行容器，并返回容器ID；</li>
<li>-P: 随机端口映射，容器内部端口随机映射到主机的端口（在 Dockerfile 中的 EXPOSE 的端口列表中选择，若没有 EXPOSE 过<strong>大概会全随机？</strong>）</li>
<li>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口。可指定多个端口映射，如<code>docker run -p 8022:22 -p 8023:23 hello-world</code></li>
<li>–name&#x3D;”容器名称”: 为容器指定一个名称；</li>
<li>-m :设置容器使用内存最大值；</li>
<li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li>
<li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li>
</ul>
<h2 id="创建新容器并启动，并进入容器内的命令行"><a href="#创建新容器并启动，并进入容器内的命令行" class="headerlink" title="创建新容器并启动，并进入容器内的命令行"></a>创建新容器并启动，并进入容器内的命令行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it &lt;镜像名称&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="查看正在运行的容器的日志-shell-的标准输出"><a href="#查看正在运行的容器的日志-shell-的标准输出" class="headerlink" title="查看正在运行的容器的日志(shell 的标准输出)"></a>查看正在运行的容器的日志(shell 的标准输出)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs &lt;containerID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="进入正在运行的容器的命令行"><a href="#进入正在运行的容器的命令行" class="headerlink" title="进入正在运行的容器的命令行"></a>进入正在运行的容器的命令行</h2><p>进入后，等于直接在容器内执行 shell 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">exec</span> -it &lt;containerID&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="从正在运行的容器内复制文件到本机"><a href="#从正在运行的容器内复制文件到本机" class="headerlink" title="从正在运行的容器内复制文件到本机"></a>从正在运行的容器内复制文件到本机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">cp</span> &lt;containID&gt;:&lt;/path/to/file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="列出本机正在运行的所有容器"><a href="#列出本机正在运行的所有容器" class="headerlink" title="列出本机正在运行的所有容器"></a>列出本机正在运行的所有容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h2 id="列出本机所有容器，无论是否运行"><a href="#列出本机所有容器，无论是否运行" class="headerlink" title="列出本机所有容器，无论是否运行"></a>列出本机所有容器，无论是否运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span> --all</span><br></pre></td></tr></table></figure>

<h2 id="正常启动容器"><a href="#正常启动容器" class="headerlink" title="正常启动容器"></a>正常启动容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;containID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="正常停止容器"><a href="#正常停止容器" class="headerlink" title="正常停止容器"></a>正常停止容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;containID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="正常重启容器"><a href="#正常重启容器" class="headerlink" title="正常重启容器"></a>正常重启容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;containID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="杀死正在运行的容器"><a href="#杀死正在运行的容器" class="headerlink" title="杀死正在运行的容器"></a>杀死正在运行的容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">kill</span> &lt;containID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [-f] &lt;containID1&gt; &lt;containID2&gt; ...</span><br></pre></td></tr></table></figure>

<p>参数<code>-f</code>可以强制删除正在运行中的容器</p>
<h2 id="获取镜像-x2F-容器的元数据"><a href="#获取镜像-x2F-容器的元数据" class="headerlink" title="获取镜像&#x2F;容器的元数据"></a>获取镜像&#x2F;容器的元数据</h2><p>可以用来获取镜像&#x2F;容器的作者。<br>一般元数据有两种参数可以定义：<code>MAINTAINER</code>与<code>LABEL</code>。其中<code>MAINTAINER</code>应该只能用来定义作者，<code>LABEL</code>更灵活。</p>
<h3 id="MAINTAINER方式构建的镜像获取其元数据"><a href="#MAINTAINER方式构建的镜像获取其元数据" class="headerlink" title="MAINTAINER方式构建的镜像获取其元数据"></a><code>MAINTAINER</code>方式构建的镜像获取其元数据</h3><p>写法应该是固定的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;<span class="string">&quot;.Author&quot;</span>&#125;&#125; &lt;镜像ID&gt;</span><br></pre></td></tr></table></figure>

<h3 id="LABEL方式构建的镜像获取其元数据"><a href="#LABEL方式构建的镜像获取其元数据" class="headerlink" title="LABEL方式构建的镜像获取其元数据"></a><code>LABEL</code>方式构建的镜像获取其元数据</h3><p>更加灵活，可以定义更多东西。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;<span class="string">&quot;.Config.Labels.&lt;定义的key&gt;&quot;</span>&#125;&#125; &lt;镜像ID&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://move-mountains.github.io/2022/05/29/Docker/Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="clc46vblb0004z8u5amhphuwg" data-title="Docker 的常用命令" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Docker/Dockerfile自定义image" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/29/Docker/Dockerfile%E8%87%AA%E5%AE%9A%E4%B9%89image/" class="article-date">
  <time class="dt-published" datetime="2022-05-29T15:20:19.000Z" itemprop="datePublished">2022-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/29/Docker/Dockerfile%E8%87%AA%E5%AE%9A%E4%B9%89image/">DockerFile构建自己的image</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Dockerfile-自定义-image"><a href="#Dockerfile-自定义-image" class="headerlink" title="Dockerfile 自定义 image"></a>Dockerfile 自定义 image</h1><h2 id="从-Dockerfile-生成-image-的基本流程"><a href="#从-Dockerfile-生成-image-的基本流程" class="headerlink" title="从 Dockerfile 生成 image 的基本流程"></a>从 Dockerfile 生成 image 的基本流程</h2><h3 id="书写-Dockerfile"><a href="#书写-Dockerfile" class="headerlink" title="书写 Dockerfile"></a>书写 Dockerfile</h3><p>按格式编写 Dockerfile，具体内容后面讲。<br>先假设需要生成的镜像是 nginx 的。<br><strong>注意：Dockerfile 只能叫 Dockerfile，不允许其他名称，也不允许改大小写。</strong></p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>先进入到存放 Dockerfile 文件的路径下，执行命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>

<p>以上命令表示构建了一个镜像名为 nginx, 标签为 v3 的镜像。<br>最后的<code>.</code>表示本次执行的上下文路径。</p>
<h4 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h4><p>docker 的运行模式为 C&#x2F;S，本机是 C，docker 引擎是 S，实际的镜像构建由 docker 引擎完成，因此引擎无法直接使用本机的文件。因此需要把所需的文件发送给引擎。<br>这个上下文路径就是指定了需要发送给 docker 引擎的文件的路径。<br>使用<code>docker build</code>命令后，这个路径下的所有文件都会发送给 docker 引擎，供 docker 引擎构建 image 使用。<br><strong>注意：构建 image 时，docker 引擎只会使用到位于上下文路径内的文件。</strong></p>
<blockquote>
<p>所以指定的路径下不应有多余的文件，虽然不影响最后生成的 image，但会拖慢构建 image 的速度（打包发送的时间变长）。</p>
</blockquote>
<h2 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>指定基础镜像，表示待自定义的镜像从这个基础镜像上修改而来。<br>一般是 Dockerfile 的第一行。</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>用于执行后面紧跟着的命令，有两种格式。<br>shell 格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"><span class="comment"># 等同于在命令行直接执行对应的指令，但控制台的输出不会在后续的 build 过程中被输出，一般用于执行创建文件夹之类的命令</span></span><br></pre></td></tr></table></figure>

<p>exec 格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span></span><br><span class="line"><span class="comment"># 执行一个可执行文件，理论上可以与上述的 shell 格式命令等价替换</span></span><br></pre></td></tr></table></figure>

<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>运行程序，但与 RUN 指令的运行时间点不同。</p>
<ul>
<li>RUN 会在 docker build 阶段执行</li>
<li>CMD 会在 docker run 时运行</li>
</ul>
<p>作用：<strong>为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。</strong>CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。<br>注意：如果 Dockerfile 中如果存在多个 CMD 指令，<strong>仅最后一个生效</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="line">CMD [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></pre></td></tr></table></figure>

<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>指定 docker run 时需默认运行的程序与默认参数。若不指定，则默认为<code>/bin/sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">&quot;&lt;executeable&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></pre></td></tr></table></figure>

<p>这个参数一般与 CMD 指令结合使用，ENTRYPOINT 中指定程序与固定参数，CMD 中指定变参。<br>如：启动 tomcat</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">&quot;catalina.sh&quot;</span>] <span class="comment"># 指定运行 catelina.sh 脚本</span></span><br><span class="line">CMD [<span class="string">&quot;run&quot;</span>] <span class="comment"># 指定调用 catalina.sh 时，传入参数 run</span></span><br></pre></td></tr></table></figure>

<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>键值对，用于给镜像添加一些元数据，没什么大用的样子。可以用来标识镜像作者。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt;</span><br><span class="line">LABEL org.opencontainers.image.authors=&quot;runoob&quot;</span><br></pre></td></tr></table></figure>

<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>环境变量，定义之后，该变量将直接写入生成的镜像内（Dockerfile 内也有效，即 docker build 的过程中也能用）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV NODE_VERSION 7.2.0</span><br></pre></td></tr></table></figure>

<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，作用与 ENV 一致，但 ARG 中定义的环境变量仅在 Dockerfile 内生效，即只在 docker build 过程中有效。<br>最后生成的 image 中不会有对应的环境变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>

<p>默认值可以设定也可以不设，不设定时，需要在<code>docker build</code>时使用参数<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来补充入参。注意：<strong>必须先在 Dockerfile 里定义了 ARG 参数，<code>--build-arg</code>才能生效</strong></p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录，由 WORKDIR 指定的工作目录将存在于构建镜像的每一层（WORKDIR 只能指定工作目录，不能自动创建，因此必须提前建好）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure>

<h4 id="相关内容：镜像与层"><a href="#相关内容：镜像与层" class="headerlink" title="相关内容：镜像与层"></a>相关内容：镜像与层</h4><p>Docker 的 image 实际是由一系列的层来构成的，Dockerfile 里的每一条命令（包括 FROM，ENV 等）都会生成新的一层。<br>所谓自定义 image，其实也就是在别人的 image 上多套几层。<br>容器由 image 生成，容器实际上也是在 image 上多套了一层可读写的层（image 里的层对容器来说都是只读的），这样就保证了 image 的一致。</p>
<blockquote>
<p>也是因为层的原因，比较推荐能写成一行的命令就写成一行，这样层数少一点，可以减小镜像的大小</p>
</blockquote>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>复制指令，从<strong>上下文目录</strong>中复制文件或者目录到容器里指定路径，指定的目标路径不存在时，会自动创建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>允许通过<code>--chown=&lt;user&gt;:&lt;group&gt;</code>可选参数，改变复制到容器内文件的拥有者和属组。<br><code>&lt;源路径&gt;</code>允许是文件或者目录，支持通配符，但通配符的格式需满足 Go 的<code>filepath.Match</code>规则（没整明白这是什么规则）</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>声明端口。运行时若使用随机端口映射(<code>docker run -P</code>)，则只会在 EXPOSE 中声明的端口列表内随机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>

<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>作用与 COPY 一致，只是针对压缩文件，使用 ADD 命令，builder 会直接解压，且若解压失败，镜像构建就会直接失败。<br>所以更推荐直接用 COPY。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://move-mountains.github.io/2022/05/29/Docker/Dockerfile%E8%87%AA%E5%AE%9A%E4%B9%89image/" data-id="clc46vbl40001z8u5bcdi7rq5" data-title="DockerFile构建自己的image" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Docker/Docker入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/29/Docker/Docker%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2022-05-29T15:18:51.000Z" itemprop="datePublished">2022-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/29/Docker/Docker%E5%85%A5%E9%97%A8/">Docker 入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Docker-入门"><a href="#Docker-入门" class="headerlink" title="Docker 入门"></a>Docker 入门</h1><p>参考文档：<a target="_blank" rel="noopener" href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">https://ruanyifeng.com/blog/2018/02/docker-tutorial.html</a><br>主要目标是整明白 DockerFile 这个东西。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>开源项目，基于 Go 语言，代码直接在 GitHub 上维护。<br>目标是实现轻量级的操作系统虚拟化解决方案，基础是 Linux 容器（LXC）等技术。<br>在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，简化操作。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p>
<blockquote>
<p>简介：Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。</p>
</blockquote>
<h3 id="相关扩展"><a href="#相关扩展" class="headerlink" title="相关扩展"></a>相关扩展</h3><h4 id="Linux-容器-Linux-Containers，缩写为-LXC"><a href="#Linux-容器-Linux-Containers，缩写为-LXC" class="headerlink" title="Linux 容器(Linux Containers，缩写为 LXC)"></a>Linux 容器(Linux Containers，缩写为 LXC)</h4><p>虚拟机的更简化的技术方案，与虚拟机一样，主要目的是做到<strong>带环境安装应用程序</strong>。在 windows 上运行 linux 系统，且应用程序毫无感知等。<br>虚拟机是模拟了一整个操作系统，会存在很多不需要的冗余，而 <strong>Linux 容器不是模拟一个完整的操作系统，只对进程进行隔离。</strong><br>容器内的进程只能接触到容器提供的各种资源，不能直接与底层系统交互，因此实现了与底层系统的隔离。<br>且 Linux 容器是进程级别的，相比虚拟机，它启动快，占用资源少，体积小。</p>
<h2 id="Docker-用途"><a href="#Docker-用途" class="headerlink" title="Docker 用途"></a>Docker 用途</h2><ul>
<li><strong>提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li>
<li><strong>提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li>
<li><strong>组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><strong>镜像（Image）</strong>：类似于虚拟机中的镜像，是一个包含有文件系统的面向 Docker 引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个 Ubuntu 镜像就是一个包含 Ubuntu 操作系统环境的模板，同理在该镜像上装上 Apache 软件，就可以称为 Apache 镜像。</li>
<li><strong>容器（Container）</strong>：类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker 引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。</li>
<li><strong>仓库（Repository）</strong>：类似于代码仓库，这里是镜像仓库，是 Docker 用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如 Ubuntu 仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。</li>
</ul>
<p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>通过这个 image 文件，Docker 才能生成对应的容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。<br>image 本身是个二进制文件，且是通用的（一个制作好的 image 可以放到任意的 Docker 服务器里生成容器实例）。所以实际开发过程中，一般都是通过继承他人的 image，加上自己的个性化设置，生成自己的个性 image 文件。<br>而为了方便共享，制作完成的 image 也可以共享到网上，Docker 有官方的 image 仓库<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。</p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h3><p>直接取官方仓库的镜可能很慢，可以换成国内镜像站。<br>在<code>/etc/default/docker</code>文件末尾添加一行</p>
<p>有几个常用的国内镜像站。阿里云的还得专门申请，就不列了</p>
<ul>
<li>科大镜像：<a target="_blank" rel="noopener" href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li>
<li>网易：<a target="_blank" rel="noopener" href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></li>
<li>七牛云加速器：<a target="_blank" rel="noopener" href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></li>
<li>腾讯云镜像: <a target="_blank" rel="noopener" href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></li>
</ul>
<p>Ubuntu14.04 与 Ubuntu16.04+&#x2F;CentOS7 的操作似乎不一样，以下仅给出 CentOS 的操作方法。</p>
<p>CentOS7 需要编辑<code>/etc/docker/daemon.json</code>文件，没有则需要新建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;&#x27; &gt;&gt;  /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;--registry-mirror=https://docker.mirrors.ustc.edu.cn&quot;</span><br></pre></td></tr></table></figure>

<p>修改后，需要重启 Docker 服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上操作操作都需要 sudo 权限</p>
</blockquote>
<h4 id="检测镜像源的修改是否生效"><a href="#检测镜像源的修改是否生效" class="headerlink" title="检测镜像源的修改是否生效"></a>检测镜像源的修改是否生效</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>应当可以在末尾看到自己指定的镜像路径<code>Registry Mirrors:</code></p>
<h3 id="从远程获取镜像"><a href="#从远程获取镜像" class="headerlink" title="从远程获取镜像"></a>从远程获取镜像</h3><p>以 hello-world 镜像为例。<br>先查找镜像列表，查询仓库里名字中含有 hello-world 的镜像</p>
<blockquote>
<p>这个命令不是太好用，显示的不太全，只能稍微验证一下。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># docker search hello-world</span></span><br><span class="line">NAME                                       DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">hello-world                                Hello World! (an example of minimal Dockeriz…   1703      [OK]       </span><br><span class="line">kitematic/hello-world-nginx                A light-weight nginx container that demonstr…   151                  </span><br><span class="line">tutum/hello-world                          Image to <span class="built_in">test</span> docker deployments. Has Apache…   88                   [OK]</span><br><span class="line">dockercloud/hello-world                    Hello World!                                    19                   [OK]</span><br><span class="line">crccheck/hello-world                       Hello World web server <span class="keyword">in</span> under 2.5 MB          15                   [OK]</span><br><span class="line">vad1mo/hello-world-rest                    A simple REST Service that echoes back all t…   5                    [OK]</span><br><span class="line">ansibleplaybookbundle/hello-world-db-apb   An APB <span class="built_in">which</span> deploys a sample Hello World! a…   2                    [OK]</span><br><span class="line">ppc64le/hello-world                        Hello World! (an example of minimal Dockeriz…   2                    </span><br><span class="line">rancher/hello-world                                                                        1                    </span><br><span class="line">ansibleplaybookbundle/hello-world-apb      An APB <span class="built_in">which</span> deploys a sample Hello World! a…   1                    [OK]</span><br><span class="line">souravpatnaik/hello-world-go               hello-world <span class="keyword">in</span> Golang                           1                    </span><br><span class="line">thomaspoignant/hello-world-rest-json       This project is a REST hello-world API to bu…   1                    </span><br><span class="line">strimzi/hello-world-consumer                                                               0                    </span><br><span class="line">strimzi/hello-world-producer                                                               0                    </span><br><span class="line">businessgeeks00/hello-world-nodejs                                                         0                    </span><br><span class="line">koudaiii/hello-world                                                                       0                    </span><br><span class="line">freddiedevops/hello-world-spring-boot                                                      0                    </span><br><span class="line">strimzi/hello-world-streams                                                                0                    </span><br><span class="line">garystafford/hello-world                   Simple hello-world Spring Boot service <span class="keyword">for</span> t…   0                    [OK]</span><br><span class="line">tsepotesting123/hello-world                                                                0                    </span><br><span class="line">armswdev/c-hello-world                     Simple hello-world C program on Alpine Linux…   0                    </span><br><span class="line">dandando/hello-world-dotnet                                                                0                    </span><br><span class="line">kevindockercompany/hello-world                                                             0                    </span><br><span class="line">okteto/hello-world                                                                         0                    </span><br><span class="line">rsperling/hello-world3                                                                     0                    </span><br></pre></td></tr></table></figure>

<p>拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure>

<p>拉取成功后，就可以在列表中看到自己的这个 hello-world 镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   6 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<h3 id="从镜像生成容器"><a href="#从镜像生成容器" class="headerlink" title="从镜像生成容器"></a>从镜像生成容器</h3><p>镜像拉取下来还只是个镜像，需要运行这个镜像以生成容器实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure>

<p><code>docker container run &lt;镜像名&gt;</code>这个命令可以从 image 文件中生成一个容器实例，并直接运行。<br>若这个命令无法从本地获取到对应的镜像，它会直接从远程仓库拉取。</p>
<p>运行成功的输出如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># docker container run hello-world</span></span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>输出以上内容后，这个容器将自动关闭（容器关闭只是不再运行，并不意味着需要再次从镜像生成新容器，事实上再调用一次镜像，生成的是一个新的容器）。<br>有些用于提供服务的容器不会自动终止，而会一直运行，如操作系统类的镜像(Ubuntu)，对这种镜像生成的运行容器，需要用命令主动终止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">kill</span> &lt;containID&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;containID&gt;</code>可以从<code>docker container ls</code>命令中获取到。</p>
<h3 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h3><p>从 image 生成的容器，其本身也是个文件，即容器文件。关闭容器也不会直接删除容器文件，只是容器不处于运行状态。<br>可以通过以下命令查看存在的容器列表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># docker container ls</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># docker container ls --all</span></span><br><span class="line">CONTAINER ID   IMAGE         COMMAND    CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">e2bbd64392ed   hello-world   <span class="string">&quot;/hello&quot;</span>   11 minutes ago   Exited (0) 11 minutes ago             distracted_banzai</span><br><span class="line">d93fa7a3bbfd   hello-world   <span class="string">&quot;/hello&quot;</span>   14 hours ago     Exited (0) 14 hours ago               wizardly_shtern</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>有了 image 文件，也可以生成容器，下一个问题是：如何构建自己的 image。<br><strong>Dockerfile 就是用来配置 image 的文本文件。</strong><br>写完自己的 Dockerfile 后，需要使用<code>docker build</code>命令生成镜像。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://move-mountains.github.io/2022/05/29/Docker/Docker%E5%85%A5%E9%97%A8/" data-id="clc46vbl70002z8u554sp7mcr" data-title="Docker 入门" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Docker/Docker安装" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/29/Docker/Docker%E5%AE%89%E8%A3%85/" class="article-date">
  <time class="dt-published" datetime="2022-05-29T15:17:11.000Z" itemprop="datePublished">2022-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/29/Docker/Docker%E5%AE%89%E8%A3%85/">Docker 安装</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>参考文档: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/kingsonfu/p/11576797.html">https://www.cnblogs.com/kingsonfu/p/11576797.html</a><br>离线与 yum 模式的都有。实操先用 yum 版本的吧。<br>后续改成用离线包的方案安装看看（这样能选安装路径，好管理）</p>
<h2 id="yum-方式安装"><a href="#yum-方式安装" class="headerlink" title="yum 方式安装"></a>yum 方式安装</h2><p>放弃脑子，复制粘贴，测试环境为腾讯云服务器<br>实际成功的参考文档:<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1701451">https://cloud.tencent.com/developer/article/1701451</a></p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol>
<li>Linux 内核：官方建议 3.10 以上，3.8 以上貌似也可。<ul>
<li>查看内核版本: <code>uname -r</code></li>
</ul>
</li>
<li>yum 安装的命令需要在 root 用户下执行，否则所有命令前都要加上 sudo。</li>
</ol>
<h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>就算没有也可以执行一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h3><p>阿里云</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>清华大学源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h3 id="查看可用的-Docker-版本"><a href="#查看可用的-Docker-版本" class="headerlink" title="查看可用的 Docker 版本"></a>查看可用的 Docker 版本</h3><blockquote>
<p>腾讯云上的服务器，如果不指定仓库，无法直接获取到 Docker 的可用版本列表。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># yum list docker-ce --showduplicates | sort -r</span></span><br><span class="line">docker-ce.x86_64                3:20.10.9-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.8-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.7-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.6-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.5-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.4-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.3-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.2-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.14-3.el8                docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.1-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.13-3.el8                docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.12-3.el8                docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.11-3.el8                docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.10-3.el8                docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.0-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:19.03.15-3.el8                docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:19.03.14-3.el8                docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:19.03.13-3.el8                docker-ce-stable</span><br><span class="line">Docker CE Stable - x86_64                        58 kB/s |  23 kB     00:00    </span><br><span class="line">上次元数据过期检查：0:00:01 前，执行于 2022年04月11日 星期一 11时17分23秒。</span><br><span class="line">可安装的软件包</span><br></pre></td></tr></table></figure>

<h3 id="安装前置软件包-不知道是否有必要，但还是做了"><a href="#安装前置软件包-不知道是否有必要，但还是做了" class="headerlink" title="安装前置软件包(不知道是否有必要，但还是做了)"></a>安装前置软件包(不知道是否有必要，但还是做了)</h3><p>安装需要的软件包， yum-util 提供 yum-config-manager 功能，另两个是 devicemapper 驱动依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>直接安装最新版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure>

<p>指定版本安装。<br>该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。<br>例如：3:20.10.6-3.el8 &#x3D;&gt; docker-ce-20.10.6</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce-20.10.9</span><br></pre></td></tr></table></figure>

<blockquote>
<p>yum -y 参数表示无视中间的提示，默认安装</p>
</blockquote>
<h3 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>完毕后可以用 version 命令检验是否正常启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># docker version</span></span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.14</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.16.15</span><br><span class="line"> Git commit:        a224086</span><br><span class="line"> Built:             Thu Mar 24 01:47:44 2022</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.9</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.16.8</span><br><span class="line">  Git commit:       79ea9d3</span><br><span class="line">  Built:            Mon Oct  4 16:06:48 2021</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     <span class="literal">false</span></span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.5.11</span><br><span class="line">  GitCommit:        3df54a852345ae127d1fa3092b95168e4a88e2f8</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.3</span><br><span class="line">  GitCommit:        v1.0.3-0-gf46b6ba</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure>

<h3 id="设置开机自动启动-可做可不做吧"><a href="#设置开机自动启动-可做可不做吧" class="headerlink" title="设置开机自动启动(可做可不做吧)"></a>设置开机自动启动(可做可不做吧)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://move-mountains.github.io/2022/05/29/Docker/Docker%E5%AE%89%E8%A3%85/" data-id="clc46vbl90003z8u502v95gf0" data-title="Docker 安装" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-日志系统/Java日志框架的简介与演变" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/29/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%BC%94%E5%8F%98/" class="article-date">
  <time class="dt-published" datetime="2022-05-29T15:02:10.000Z" itemprop="datePublished">2022-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/29/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%BC%94%E5%8F%98/">Java 日志框架的简介与演变</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java-日志框架的简介与演变"><a href="#Java-日志框架的简介与演变" class="headerlink" title="Java 日志框架的简介与演变"></a>Java 日志框架的简介与演变</h1><blockquote>
<p>参考文献:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64353891">https://zhuanlan.zhihu.com/p/64353891</a></p>
</blockquote>
<p>几个常见的日志相关的关键词:Log4j, JUL, SLF4J, Log4j2, JCL, logback。</p>
<h2 id="演变的简介"><a href="#演变的简介" class="headerlink" title="演变的简介"></a>演变的简介</h2><ol>
<li>Apache 开源社区里的 Log4j 是最早出现的<strong>日志工具</strong>。应用最广泛，成了 Java 日志的事实标准。</li>
<li>Sun 公司随后在 Jdk1.4 版本中加入了 JUL(java.util.logging)，对标 Log4j,算是对抗。</li>
<li>有了两个日志工具以后，日志的统一就比较困难了。自己的代码可以统一使用一个 log 工具，但引入的第三方库和包可能用的就是另一种，日志工具之间互不兼容，无法统一管理的日志看着也头疼。</li>
<li>为了解决“无法统一管理日志”这一痛点，Apache 开源社区就掏出了 commons-logging 这个<strong>日志框架</strong>，即 JCL(java common logging)。它的作用就是对各种日志接口进行抽象，抽象出一个接口层，然后对每一个日志工具都实现适配（适配器模式），开发者使用时，直接调用抽象层的接口即可。JCL 完成了兼容主流日志(Log4j, JUL, simplelog等)的工作，spring 也依赖了 JCL。</li>
<li>Log4j 作者又开发了一套<strong>日志框架</strong> SLF4J,即简单日志门面（Simple Logging Facade for Java），并为此做了一套实现：logback。<ul>
<li>SLF4J 是抽象层，对标 JCL, logback 是具体实现，对标 log4j, JUL 等。</li>
</ul>
</li>
<li>随后 Log4j 作者又对 Log4j 做了改造，Log4j2 出世，它同时支持 JCL 与 SLF4J 两个日志框架。</li>
</ol>
<h3 id="演变的简单总结"><a href="#演变的简单总结" class="headerlink" title="演变的简单总结"></a>演变的简单总结</h3><ol>
<li>日志库 Log4j，JUL，logback 是互相不兼容的，没有共同的 Interface，所以 commons-logging、SLF4J 通过适配器模式，抽象出来一个共同的接口，然后根据使用的具体日志框架来实现日志。</li>
<li>JCL(java common logging) 和 SLF4J 都是日志的接口，供用户使用，而没有提供实现，Log4j，JUL，logback 等等才是日志的真正实现。</li>
<li>当我们调用日志接口时，接口会自动寻找恰当的实现，返回一个合适的实例给我们服务。这些过程都是透明化的，用户不需要进行任何操作。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://move-mountains.github.io/2022/05/29/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%BC%94%E5%8F%98/" data-id="clc46vble0005z8u5858b0d8m" data-title="Java 日志框架的简介与演变" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/28/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-05-28T08:40:52.917Z" itemprop="datePublished">2022-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://move-mountains.github.io/2022/05/28/hello-world/" data-id="clc46vbkx0000z8u54gmq84mp" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/29/Docker/Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 的常用命令</a>
          </li>
        
          <li>
            <a href="/2022/05/29/Docker/Dockerfile%E8%87%AA%E5%AE%9A%E4%B9%89image/">DockerFile构建自己的image</a>
          </li>
        
          <li>
            <a href="/2022/05/29/Docker/Docker%E5%85%A5%E9%97%A8/">Docker 入门</a>
          </li>
        
          <li>
            <a href="/2022/05/29/Docker/Docker%E5%AE%89%E8%A3%85/">Docker 安装</a>
          </li>
        
          <li>
            <a href="/2022/05/29/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%BC%94%E5%8F%98/">Java 日志框架的简介与演变</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>